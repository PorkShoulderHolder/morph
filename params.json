{
  "name": "Morph",
  "tagline": "mathematical morphology for javascript",
  "body": "#morph.js\r\n========\r\n\r\n\r\n###Morphological image processing for javascript.\r\n\r\n\r\nThe purpose of morph.js is to make the low level image processing and computer vision functions defined by mathematical morphology available for use with preproccessed input from the webcam via window.getUserMedia(). Morph.js deals with binary images, in other words, all operations are done on arrays of ones and zeroes. \r\n\r\n\r\n\r\n###Mathematical Morphology as described by wikipedia:\r\n\r\nMathematical morphology (MM) is a theory and technique for the analysis and processing of geometrical structures, based on set theory, lattice theory, topology, and random functions. MM is most commonly applied to digital images, but it can be employed as well on graphs, surface meshes, solids, and many other spatial structures.\r\nTopological and geometrical continuous-space concepts such as size, shape, convexity, connectivity, and geodesic distance, were introduced by MM on both continuous and discrete spaces. MM is also the foundation of morphological image processing, which consists of a set of operators that transform images according to the above characterizations.\r\nMM was originally developed for binary images, and was later extended to grayscale functions and images. The subsequent generalization to complete lattices is widely accepted today as MM's theoretical foundation.\r\n\r\n\r\n##Usage\r\n\r\nTo initialize a morph object:\r\n    \r\n    var height = 200\r\n    var width = 270\r\n    var morph = new Morph(height, width, bits)\r\n\r\nwhere bits is an array of 1s and 0s with length (height * width), usually derived from some image.\r\n\r\nBasic functionality in Morphological image processing (MIP) is defined by the erode and dilate operations.\r\n\r\n    \r\n###Erosion\r\n\r\n    morph.erodeWithElement()\r\n\r\nwhen no structuring element argument is provided all operations default to using a default 3x3 rectangular structuring element that looks like this:\r\n\r\n    [1,1,1,\r\n     1,1,1,\r\n     1,1,1]\r\n     \r\nAnd will provide results like this:     \r\n\r\n![ScreenShot](https://www.cs.auckland.ac.nz/courses/compsci773s1c/lectures/ImageProcessing-html/mor-pri-erosion.gif)\r\n\r\nUsers can select from other predefined structuring elements like MORPH_3x3_CROSS_ELEMENT, or define their own structuring elements:\r\n\r\n    var el = new StructuringElement(3,[1,1,1,\r\n                                       0,1,0,\r\n                                       0,0,0])\r\n                                       \r\nWhere the 1st argument is the dimension of the element. \r\n\r\n\r\n###Dilation\r\n\r\n    morph.dilateWithElement()\r\n\r\nWill provide results like this:\r\n\r\n![ScreenShot](http://angelinagokhale.files.wordpress.com/2013/04/diltbin.gif)\r\n\r\nExample usage: http://somatostat.in/swarmSandbox.html\r\n\r\n\r\n###Closing\r\n\r\nIn image processing, closing is, together with opening, the basic workhorse of morphological noise removal. Opening removes small objects, while closing removes small holes [wikipedia]. \r\n\r\n    morph.closingWithElement()\r\n\r\nClosing is the dilation operation followed by the erosion operation and depending on the structuring elements used, gives an effect similar to below. \r\n\r\n![ScreenShot](http://homepages.inf.ed.ac.uk/rbf/HIPR2/figs/closebin.gif)\r\n\r\n\r\n###Opening\r\n\r\n    morph.openingWithElement()\r\n    \r\neffect:\r\n\r\n![ScreenShot](http://homepages.inf.ed.ac.uk/rbf/HIPR2/figs/openbin.gif)\r\n    \r\nremoving a small object with opening:\r\n    \r\n![ScreenShot](http://patentimages.storage.googleapis.com/WO2005107581A2/imgf000071_0001.png)\r\n\r\n\r\n\r\n###Hit-Miss Transform\r\n\r\nThe hit-miss transform can be described as a very simplistic corner detector. In morph.js you cannot specify the structuring elements used in the hit-miss transform.   \r\n\r\n    morph.hitMissTransform()\r\n\r\nHere is the effect:\r\n\r\n![ScreenShot](http://www.cse.dmu.ac.uk/~sexton/WWWPages/HIPR/figs/hamcrn.gif)\r\n\r\n\r\n###Iterative Thinning\r\n\r\nThinning is the act of iteratively subtracting the hit miss transform from the image it was generated from. \r\n    \r\n    var iterations = 6;\r\n    morph.iterativeThinning(iterations);\r\n\r\nIf you set the parameter high enough then it will eventually converge to the 'skeletonization' of the image, shown below.\r\n\r\n![ScreenShot](http://homepages.inf.ed.ac.uk/rbf/HIPR2/figs/thnskxmp.gif)\r\n\r\nBe aware: the time complexity of reaching a complete skeletonization is prohibitive for most real-time processing applications.\r\n\r\n###Connected Component Labeling\r\n\r\n    var componentData = morph.labelConnectedComponents()\r\n    componentData.contours.forEach(function(contour){\r\n    \r\n        console.log(contour)\r\n        \r\n        // returns an array of normalized x,y values [ [0.1,0.2], [0.8,0.1], .... ] \r\n\r\n    })\r\n    \r\n\r\nThis is (in my opinion) the most useful algo in morph.js. Given a binary image, it will label connected sections with integers (not neccesarily consecutive). It is an implementation of the \"two pass\" algorithm described on wikipedia (http://en.wikipedia.org/wiki/Connected-component_labeling), and labels regions that are \"8-connected\". It is also relatively speedy, running linearly wrt the number of pixels. Using the connected component data you can color a bitmap image like this:\r\n\r\n![ScreenShot](http://upload.wikimedia.org/wikipedia/commons/thumb/a/ae/Screenshot-Figure_1.png/800px-Screenshot-Figure_1.png)\r\n\r\n\r\nFor more info about morphological image proccessing, check out this site, which I referenced extensively above: http://homepages.inf.ed.ac.uk/rbf/HIPR2/morops.htm \r\n\r\n\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}